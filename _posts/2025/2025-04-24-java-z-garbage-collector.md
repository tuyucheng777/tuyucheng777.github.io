---
layout: post
title:  利用分代ZGC实现最佳临时对象管理
category: java-new
copyright: java-new
excerpt: Java 21
---

## 1. 简介

**管理临时对象是Java虚拟机优化中至关重要的性能因素**，随着Java 21中[分代ZGC](https://www.baeldung.com/java-21-generational-z-garbage-collector)(Z垃圾回收器)的引入(现已在Java 22中提供)，我们进入了内存管理的新时代，可以有效地处理短暂生存的对象。

在本教程中，我们将详细探讨分代ZGC，并讨论它如何增强临时对象的管理，我们将展示它如何有助于提高JVM性能的整体水平。最后，我们将分享一个实际用例，让你从新学到的知识中受益。

## 2. Java中的临时对象

**临时或短暂对象是在程序执行期间创建的具有较短生命周期的对象**。

一般来说，此类对象是中间结果、方法参数或临时数据结构。在许多Java程序中，大部分对象都属于此类。在涉及频繁方法调用、临时计算或快速数据转换的应用程序中尤其如此。

作为示例，我们将考虑Java中临时对象的生命周期，特别是在Web请求的上下文中，这包括它们在客户端-服务器交互期间的创建、处理和最终处置。

客户端首先通过向服务器发送HTTP请求与服务器通信，该请求提示服务器生成要处理的临时请求对象。在服务器处理请求时，它可能会创建其他临时对象用于计算和数据管理(例如访问或修改作为临时对象保存的会话数据)。

完成后，服务器会将HTTP响应封装在临时响应对象中返回给客户端。最后，一旦收到响应，服务器就会销毁请求期间生成的临时对象以释放内存。

下图表示Web请求上下文中临时对象的生命周期：

![](/assets/images/2025/javanew/javazgarbagecollector01.png)

它概述了Web请求期间临时对象的生命周期所涉及的步骤，从最初的用户操作到处理后的临时对象的清理。

## 3. ZGC的演变

从Java 11开始引入的[ZGC](https://www.infoq.com/news/2023/07/java-enhance-zgc/)是JVM垃圾回收演进的最新里程碑，ZGC具有低延迟和可扩展性的特点，使其成为低延迟服务器工作负载的理想选择。

随后的每个Java版本都通过额外的优化增强了ZGC，2023年4月，在预览版发布后，Java 21中推出了分代ZGC，以改进临时对象管理。

## 4. 分代ZGC的工作原理

**分代ZGC将堆分为两部分：一部分用于新创建的对象(新生代)，另一部分用于寿命较长的对象(老年代)**。

### 4.1 对象分配和年轻代回收

年轻对象最初分配在ZGC的年轻代中，这是一块专为短期生存对象定制的内存区域。

年轻代的回收频率比老年代高得多，这意味着可以快速从不再使用的对象中回收内存。

### 4.2 优化并发回收

**新生代的回收过程使用并发标记和撤离技术**，这种双重方法允许ZGC在应用程序运行时标记符合回收条件的对象。

减少应用程序线程的重复中断可降低应用程序延迟并提高性能灵敏度。

### 4.3 对象提升和动态阈值

**在年轻代中存活了几个回收周期后，对象会被提升到老年代**，这种机制将生命周期较短的对象与可能存活较长的对象隔离开来，ZGC会根据观察到的对象生命周期分布动态调整生命周期阈值。

提升阈值决定了对象何时应从年轻代提升至老年代，这种灵活性通过仅提升那些需要长期存储的对象来进一步帮助优化内存使用率。

### 4.4 老年代回收

老年代的回收频率低于年轻代，因为它主要包含那些经历了多次垃圾回收周期的长寿命对象，老年代的回收旨在回收未使用对象的内存。

由于其他应用程序部分的引用，这些对象可能在内存中停留更长时间。老年代回收器与年轻代回收器类似，也使用并发技术，这确保了在垃圾回收器回收未使用的内存时，应用程序线程能够以最小的中断继续运行。

## 5. 视觉展示

为了更好地理解分代ZGC的机制，让我们将这个过程形象化。

![](/assets/images/2025/javanew/javazgarbagecollector02.png)

**对象在年轻代中分配，经常使用并发标记和撤离技术进行回收**，这种频繁分配意味着我们可以快速从临时对象中回收内存，从而有助于保持低延迟和高性能。

那些在多次回收中幸存下来的对象将被移至老年代，该区域的内存回收频率较低，该算法会根据对象生命周期自动调整提升阈值，从而优化长寿命对象的内存管理。

## 6. 临时对象的性能影响

分代ZGC的引入对于创建许多临时对象的应用程序具有重要意义。

### 6.1 减少GC开销

**分代ZGC为Java应用程序带来了高性能提升，尤其是在管理临时对象方面**。因此，GC开销更少。

通过在大多数短寿命对象所在的年轻代中执行工作，分代ZGC可以快速回收内存，而无需执行昂贵的全堆回收，这可以减少垃圾回收所花费的时间，并将更多时间用于实际应用程序处理。

### 6.2 提高吞吐量

分代ZGC的另一个好处是提高了吞吐量，[内部基准测试](https://inside.java/2023/11/28/gen-zgc-explainer/)表明，与非分代前代产品相比，吞吐量提高了10%。

处理大量数据或大量并发操作的应用程序将受益于这项改进，因此，应用程序可以在更短的时间内处理更多的工作，而且通常不需要额外的计算资源。

### 6.3 减少暂停时间

**在P99[暂停时间](https://netflixtechblog.com/bending-pause-times-to-your-will-with-generational-zgc-256629c9386b)方面，分代ZGC可将应用程序响应速度提高约10%-20%**，对于低延迟或恒定响应时间是关键成功因素的应用程序来说，减少停顿时间至关重要。

对于诸如股票套利的实时交易系统或对延迟敏感的Web服务等应用来说，情况尤其如此，在这种情况下，一个能够最大程度减少暂停时间的Stop-the-world回收器对于维持应用程序的响应能力至关重要，这在高负载或高峰使用期间尤其重要。

### 6.4 高效内存回收

由于分代ZGC在回收内存方面比任何其他GC方法都更高效，因此它降低了在高分配负载下出现[内存不足错误](https://www.baeldung.com/java-gc-overhead-limit-exceeded)的可能性。通过密切跟踪短命对象的生命周期，GC可以更积极地提升它们。

这样可以更快地回收未使用的内存，从而腾出空间用于新分配。此行为对于分配率高且创建大量临时对象的应用程序尤其重要，它有助于保持GC的延迟影响可预测，并防止因内存耗尽而导致崩溃。

### 6.5 总结

下表总结了分代ZGC对临时对象的性能影响：

|     方面|                         描述|                       影响|
| :----------: | :---------------------------------------------------: | :----------------------------------------------: |
| 减少GC开销| 分代ZGC通过重点关注年轻代中的短命对象来快速回收内存|        减少垃圾回收时间，增加应用程序时间|
|  提高吞吐量|          与上一代产品相比，吞吐量提高了10%           |     应用程序可以在更短的时间内处理更多的工作|
| 减少暂停时间|       低延迟应用程序的P99暂停时间减少10-20%        | 提高应用程序响应能力，这对于实时应用程序至关重要|
| 高效内存回收|           有效的内存回收可减少内存不足错误|          帮助管理高分配率，防止内存耗尽|

上表展示了分代ZGC在性能敏感型应用程序中管理临时对象的优势。

## 7. 用例：使用实时数据的高频交易

在[高频交易](https://www.investopedia.com/terms/h/high-frequency-trading.asp)(HFT)中，速度至关重要，每秒处理数百万个市场数据点，生成交易，系统执行快速计算。这种处理会产生临时对象，例如交易订单和市场快照，这些对象可能只存在很短的时间。

### 7.1 分代ZGC如何提供帮助

**分代ZGC几乎在这些短暂的对象被创建后立即回收它们，有助于避免内存开销**。

ZGC引擎在后台运行，不会因交易而暂停，电子交易中哪怕只有一微秒的暂停也可能意味着错失有利可图的交易。

### 7.2 提高吞吐量

随着数据快速涌入，系统必须快速处理海量数据，且速度不减。分代ZGC会以最快的速度清除累积的临时对象，确保内存为下一轮计算做好准备。因此，即使市场繁忙，系统也能持续运行。

### 7.3 避免内存崩溃

高频交易平台每秒钟都会产生数百万个对象，内存管理必须非常高效，以免系统内存耗尽而崩溃。

随着短期对象被丢弃，ZGC不断释放空间。

### 7.4 随着市场扩大规模

随着交易量的增加，系统必须在不降低性能的情况下处理更多数据，该平台借助分代ZGC轻松扩展，即使工作负载增加一倍或两倍，也能高效利用内存。

## 8. 针对分代ZGC优化应用程序

我们应该遵循一些最佳实践来充分利用分代ZGC的潜力，尤其是在处理临时对象时。

### 8.1 重新评估对象池

**对象池曾经是最常见的优化方式，即重用对象而不是创建新对象，以优化内存和GC消耗**。但是，由于分代ZGC可以有效地处理临时对象，因此激进的对象池可能不再是必要的，甚至可能导致性能问题。

### 8.2 识别对象分配模式

分析工具有助于识别代码中生成过多临时对象的部分，可视化此过程有助于理解和优化应用程序。**我们可以使用JDK Mission Control、VisualVM或JProfiler等[分析工具](https://www.baeldung.com/java-profilers)来收集实时对象分配情况**，我们可以将分析的序列图可视化：

![](/assets/images/2025/javanew/javazgarbagecollector03.png)

开发人员启动性能分析来监控对象分配情况，促使性能分析器对应用程序代码进行检测并收集数据。然后，开发人员分析报告以识别热点并相应地优化代码。

### 8.3 调整分代ZGC的堆大小

考虑堆大小调整非常重要，**我们可以调整堆大小，以根据特定的工作负载在年轻代和老年代大小之间找到合适的平衡**。下图展示了堆大小调整的流程图：

![](/assets/images/2025/javanew/javazgarbagecollector04.png)

我们首先使用默认堆大小运行应用程序，并监控性能指标以检查是否存在较高的临时对象分配，如果检测到较高的分配，我们会调整年轻代的大小并重新运行应用程序。我们会继续此过程，不断优化堆大小，直到确定最佳配置。

### 8.4 监控和调整垃圾回收

持续监控有助于微调GC行为，从而提升应用程序性能，[JDK Flight Recorder](https://www.baeldung.com/java-flight-recorder-view)(JFR)和[JDK Mission Control](https://www.oracle.com/java/technologies/jdk-mission-control.html)(JMC)等工具可以帮助监控GC行为并提高性能，我们可以将GC监控和调优的序列图可视化如下：

![](/assets/images/2025/javanew/javazgarbagecollector05.png)

开发者启用GC日志记录并启动应用程序，以便记录和分析垃圾回收事件，从而识别性能问题。基于此分析，开发人员调整GC参数并重新启动应用程序以应用优化。

## 9. 未来方向

随着分代ZGC的成熟，我们可以期待进一步的优化和功能：

- **自适应代大小调整**：更复杂的算法，可根据应用程序行为动态调整年轻代和老代的大小
- **增强的预测回收**：改进的启发式方法，用于预测何时在每一代触发回收
- **与JIT优化集成**：加强GC和[JIT编译器](https://www.baeldung.com/graal-java-jit-compiler)之间的合作，以实现更好的对象分配和管理
- **针对特定对象类型的专门处理**：针对Java应用程序中常见的短生命周期对象模式进行潜在优化

## 10. 总结

在本文中，我们了解到分代ZGC是JVM垃圾回收技术的一个重要创新，它建立在分代假设的基础上，能够更有效地回收短生命周期对象的垃圾，这能够提升各种Java应用程序的性能。

吞吐量、延迟和整体应用程序性能的提升是考虑在现代Java部署中使用分代ZGC的有力理由，当存在长时间对象分配时尤其如此。